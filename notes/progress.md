# Performance-Aware Programming

## Episodes

### Prologue: The Five Multipliers

- [x] 001 - Welcome To The Performance-Aware Programming Series!

- [x] 002 - Waste

- [x] 003 - Instructions Per Clock

- [x] 004 - Monday Q&A #1 (2023-02-05)

- [x] 005 - Single Instruction, Multiple Data (Simd)

- [x] 006 - Caching

- [x] 007 - Monday Q&A #2 (2023-02-12)

- [x] 008 - Multithreading

- [x] 009 - Python Revisited

- [x] 010 - Monday Q&A #3 (2023-02-20)

### Interlude

- [x] 011 - The Haversine Distance Problem

- [x] 012 - Clean Code, Horrible Performance

### Part 1: Reading ASM

- [ ] 013 - Instruction Decoding On The 8086

- [ ] 014 - Decoding Multiple Instructions And Suffixes

- [ ] 015 - Monday Q&A #4 (2023-03-06)

- [ ] 016 - Opcode Patterns In 8086 Arithmetic

- [ ] 017 - Monday Q&A #5 (2023-03-13)

- [ ] 018 - 8086 Decoder Code Review

- [ ] 019 - Monday Q&A #6 (2023-03-20)

- [ ] 020 - Using The Reference Decoder As A Shared Library

- [ ] 021 - Simulating Non-Memory MOVs

- [ ] 022 - Simulating ADD, SUB, And CMP

- [ ] 023 - Simulating Conditional Jumps

- [ ] 024 - Monday Q&A #7 (2023-04-10)

- [ ] 025 - Simulating Memory

- [ ] 026 - Simulating Real Programs

- [ ] 027 - Monday Q&A #8 (2023-04-17)

- [ ] 028 - Other Common Instructions

- [ ] 029 - The Stack

- [ ] 030 - Monday Q&A #9 (2023-04-24)

- [ ] 031 - Performance Excuses Debunked

- [ ] 032 - Estimating Cycles

- [ ] 033 - Monday Q&A #10 (2023-05-08)

- [ ] 034 - From 8086 To X64

- [ ] 035 - Monday Q&A #11 (2023-05-15)

- [ ] 036 - 8086 Simulation Code Review

- [ ] 037 - Monday Q&A #12 (2023-05-22)

### Part 2: Basic Profiling

- [ ] 038 - Generating Haversine Input Json

- [ ] 039 - Monday Q&A #13 (2023-05-29)

- [ ] 040 - Writing A Simple Haversine Distance Processor

- [ ] 041 - Monday Q&A #14 (2023-06-05)

- [ ] 042 - Initial Haversine Processor Code Review

- [ ] 043 - Monday Q&A #15 (2023-06-12)

- [ ] 044 - Introduction To RDTSC

- [ ] 045 - Monday Q&A #16 (2023-06-19)

- [ ] 046 - How Does QueryPerformanceCounter Measure Time

- [ ] 047 - Monday Q&A #17 (2023-06-26)

- [ ] 048 - Instrumentation-Based Profiling

- [ ] 049 - Monday Q&A #18 (2023-07-03)

- [ ] 050 - Profiling Nested Blocks

- [ ] 051 - Monday Q&A #19 (2023-07-10)

- [ ] 052 - Profiling Recursive Blocks

- [ ] 053 - Monday Q&A #20 (2023-07-17)

- [ ] 054 - A First Look At Profiling Overhead

- [ ] 055 - Comparing The Overhead Of RDTSC And QueryPerformanceCounter

- [ ] 056 - Monday Q&A #21 (2023-07-31)

- [ ] 057 - Q&A #22 (2023-08-15)

### Part 3: Moving Data

- [ ] 058 - Measuring Data Throughput

- [ ] 059 - Q&A #23 (2023-08-21)

- [ ] 060 - Repetition Testing

- [ ] 061 - Q&A #24 (2023-08-28)

- [ ] 062 - Monitoring OS Performance Counters

- [ ] 063 - Q&A #25 (2023-09-04)

- [ ] 064 - Page Faults

- [ ] 065 - Q&A #26 (2023-09-11)

- [ ] 066 - Probing OS Page Fault Behavior

- [ ] 067 - Q&A #27 (2023-09-18)

- [ ] 068 - Four-Level Paging

- [ ] 069 - Q&A #28 (2023-09-25)

- [ ] 070 - Analyzing Page Fault Anomalies

- [ ] 071 - Q&A #29 (2023-10-02)

- [ ] 072 - Powerful Page Mapping Techniques

- [ ] 073 - Q&A #30 (2023-10-09)

- [ ] 074 - Faster Reads With Large Page Allocations
